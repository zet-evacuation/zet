package de.tu_berlin.math.coga.rndutils;

import de.tu_berlin.math.coga.rndutils.generators.GeneralRandom;
import de.tu_berlin.math.coga.rndutils.generators.MersenneTwister;
import java.security.SecureRandom;
import java.util.ArrayList;

/**
 * This singleton class provides access to a project wide random number
 * generator and some useful methods concerning random numbers.
 * @author Jan-Philipp Kappmeier, Matthias Woste
 */
public class RandomUtils {
	/** List of seeds for the random generators. */
	private ArrayList<Long> seeds = new ArrayList<Long>(1);
	/** List of random generators for the threads. */
	private ArrayList<GeneralRandom> randomGenerator = new ArrayList<GeneralRandom>(1);
	/** Contains the RandomUtils object. */
	private static RandomUtils instance;

	/**
	 * Returns this singleton object
	 * @return singleton instance of {@code RandomUtils}
	 */
	public static RandomUtils getInstance() {
		return instance == null ? instance = new RandomUtils() : instance;
	}

	/**
	 * Initializes an Random object with a seed generated by a {@link SecureRandom} object
	 */
	private RandomUtils() {
		SecureRandom secRandom = new SecureRandom();
		secRandom.setSeed( SecureRandom.getSeed( 16 ) );
		seeds.set( 0, secRandom.nextLong() );
		seeds.set( 0, -7566781686001723112l );
		randomGenerator.set( 0, new MersenneTwister( seeds.get( 0 ) ) );
	}

	/**
	 * Returns the initials seed used for the first thread.
	 * @return the seed
	 */
	public long getSeed() {
		return seeds.get( 0 );
	}

	/**
	 * Sets the seed to the passed value and restarts the random number generator with this seed.
	 * @param seed The seed used for initialization.
	 */
	public void setSeed( long seed ) {
		seeds.set( 0, seed );
		restart();
	}

	/**
	 * Sets a specific seed and resets the random generator belonging to that seed.
	 * @param pos the thread/generator number (starting with zero)
	 * @param seed the seed
	 * @throws IllegalArgumentException if the thread id is higher than the current number of threads
	 */
	public void setSeed( int threadID, long seed ) throws IllegalArgumentException {
		if( threadID > seeds.size() -1 )
			throw new IllegalArgumentException( "Not enough seeds!" );
		seeds.set( threadID, seed );
		randomGenerator.set( threadID, new MersenneTwister( seed ) );
	}

	/**
	 * Returns the number of parallel random generators, or, the number of
	 * supported threads.
	 * @return the number of parallel random generators.
	 */
	public int getThreadCount() {
		return seeds.size();
	}

	/**
	 * Restarts the random number generator with the seed saved in this object. If
	 * more than one random generator are present, only the first one is restarted.
	 */
	public void restart() {
		randomGenerator.set( 0, new MersenneTwister( seeds.get( 0 ) ) );
	}

	/**
	 * Resets all random generators with the seeds stored in the seeds list.
	 */
	public void restartAll() {
		for( int i = 0; i < seeds.size(); ++i )
			randomGenerator.set( i, new MersenneTwister( seeds.get( i ) ) );
	}

	/**
	 * Restarts with a number of random generators with random seeds.
	 * @param threadCount the number of threads (generators that are created)
	 * @throws IllegalArgumentException if the number of threads is less or equal to zero
	 */
	public void restart( int threadCount ) throws IllegalArgumentException {
		if( threadCount <= 0 )
			throw new IllegalArgumentException( "At least one thread!" );
		seeds.clear();
		randomGenerator.clear();
		seeds = new ArrayList<Long>( threadCount );
		randomGenerator = new ArrayList<GeneralRandom>( threadCount );
		for( int i = 0; i < threadCount; ++i ) {
			seeds.set( i, System.nanoTime() );
			randomGenerator.set( i, new MersenneTwister( seeds.get( i ) ) );
		}
	}

	/**
	 * Resets all random generators. Creates as much random generators as the
	 * length of the array is. The generators are initialized with the given seed.
	 * @param seeds an array of seeds that are used
	 * @throws IllegalArgumentException if the array is empty or {@code null}
	 */
	public void restart( long[] seeds ) throws IllegalArgumentException {
		if( seeds == null || seeds.length <= 0 )
			throw new IllegalArgumentException( "At least one thread!" );
		this.seeds.clear();
		randomGenerator.clear();
		this.seeds = new ArrayList<Long>( seeds.length );
		randomGenerator = new ArrayList<GeneralRandom>( seeds.length );
		for( int i = 0; i < seeds.length; ++i ) {
			this.seeds.set( i, seeds[i] );
			randomGenerator.set( i, new MersenneTwister( seeds[i] ) );
		}
	}

	public void addGenerator( long seed ) {
		seeds.add( seed );
		randomGenerator.add( new MersenneTwister( seed ) );
	}

	public void addGenerator( ) {
		seeds.add( System.nanoTime() );
		randomGenerator.add( new MersenneTwister( seeds.get( seeds.size()-1 ) ) );
	}

	/**
	 * Returns the random number generator as an object of type Random.
	 * @return an object of type Random.
	 */
	public GeneralRandom getRandomGenerator() {
		return randomGenerator.get( 0 );
	}

	/**
	 * Returns the random number generator for the passed thread.
	 * @param thread the thread id
	 * @return the random generator for the thread
	 * @throws IndexOutOfBoundsException if index is out of range ({@code index < 0 || index >= size()}).
	 */
	public GeneralRandom getRandomGenerator( int thread ) throws IndexOutOfBoundsException {
		return randomGenerator.get( thread );
	}

	/**
	 * Sets a new random generator for the first (or only) thread. Do know what
	 * you do, if you call it. The seeds array will (maybe) no longer represent
	 * the correct seeds.
	 * @param r
	 */
	public void setRandomGenerator( GeneralRandom r ) {
		randomGenerator.set( 0, r );
	}

	/**
	 * Takes a random, binary decision.
	 * @param probability A number between 0 and 1
	 * @return <code>true</code> with probability <code>probability</code> and
	 * <code>false</code> otherwise.
	 */
	public boolean binaryDecision( double probability ) {
		double randomNumber = getRandomGenerator().nextDouble();
		//System.out.println( "Randomnumber " + randomNumber + " in binaryDecision" );
		return (randomNumber <= probability);
	}

	/**
	 * Picks an integer with respect to a discrete distribution.
	 * @param probabilities A discrete distribution. The entry with index i should
	 * contain the probability of i
	 * @return A number between <code>0</code> and <code>probabilities.length-1</code>
	 */
	public int chooseRandomly( double[] probabilities ) {
		int probability = 0;
		final double randomNumber = getRandomGenerator().nextDouble();
		int i = 0;
		while( probability <= randomNumber && i < probabilities.length ) {
			if( probabilities[i] < 0 )
				throw new IllegalArgumentException( "Negative probabilities are not " +
								"allowed! (" + probabilities[i] + " at index " + i + ")" );
			probability += probabilities[i];
			i++;
		}

		return i - 1;
	}

	/**
	 * Picks an integer with respect to a discrete distribution given by
	 * an array of absolute frequencies.
	 * @param frequencies A discrete distribution. The entry with index i should
	 * contain the frequency of i
	 * @return A number between <code>0</code> and <code>probabilities.length-1</code>
	 */
	public int chooseRandomlyAbsolute( double[] frequencies ) {
		int sum = 0;
		for( int i = 0; i < frequencies.length; i++ ) {
			if( frequencies[i] < 0 )
				throw new IllegalArgumentException( "Negative frequencies are not " +
								"allowed! (" + frequencies[i] + " at index " + i + ")" );

			sum += frequencies[i];
		}

		double probability = 0;
		double randomNumber = getRandomGenerator().nextDouble();
		int i = 0;
		while( probability <= randomNumber * sum && i < frequencies.length ) {
			probability += frequencies[i];
			i++;
		}

		return i - 1;
	}
}
